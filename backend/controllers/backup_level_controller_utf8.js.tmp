import Level from '../models/level.model.js';
import User from '../models/user.model.js';
import { ApiError } from '../middlewares/error.middleware.js';
import { distributeNetworkRewards, getUserNetworkRewardsForLevel } from '../utils/level-distribution.js';
import { fetchConversionRates } from '../utils/crypto-conversion.js';

// Get all levels
export const getLevels = async (req, res, next) => {
  try {
    const { userId, templateName } = req.query;

    let activeTemplate = templateName || 'A';
    let user = null;

    if (userId) {
      user = await User.findById(userId);
      if (user) {
        activeTemplate = user.levelTemplate || 'A';
      }
    }

    const query = activeTemplate === 'A'
      ? { $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { templateName: activeTemplate };

    const levels = await Level.find(query).sort({ level: 1 });

    // If userId is provided, apply user-specific network reward distribution
    let processedLevels = levels;
    if (userId && user) {
      // Fetch conversion rates from database/cache
      const conversionRates = await fetchConversionRates();

      let needsSave = false;
      processedLevels = levels.map(level => {
        const userNetworkRewards = getUserNetworkRewardsForLevel(user, level.level);
        const levelObj = level.toObject();

        // Get stored distribution for this level to prevent re-randomization
        const storedDistField = `lvl${level.level}DistributedNodes`;
        const storedDist = user[storedDistField] ? Object.fromEntries(user[storedDistField]) : null;

        // Distribute rewards (will use stored if available, or create new)
        const { levelData, newDistribution } = distributeNetworkRewards(levelObj, userNetworkRewards, conversionRates, storedDist);

        // If new distribution was created (first time), save it to user
        if (newDistribution) {
          user[storedDistField] = new Map(Object.entries(newDistribution));
          needsSave = true;
          console.log(`[Level Controller] Stored new distribution for user ${userId}, level ${level.level}`);
        }

        return levelData;
      });

      // Save user if new distributions were created
      if (needsSave) {
        await user.save();
      }

      console.log(`[Level Controller] Applied user-specific USD rewards for user ${userId}`);
    } else {
      console.log(`[Level Controller] User ${userId} not found or not provided, returning default levels for template ${activeTemplate}`);
    }

    res.status(200).json({
      success: true,
      message: 'Levels retrieved successfully',
      data: {
        levels: processedLevels,
        count: processedLevels.length
      }
    });
  } catch (error) {
    next(error);
  }
};

// Get specific level by level number
export const getLevelById = async (req, res, next) => {
  try {
    const { levelId } = req.params;
    const { userId, templateName } = req.query;
    const levelNumber = parseInt(levelId);

    if (isNaN(levelNumber)) {
      throw new ApiError(400, 'Invalid level ID');
    }

    let activeTemplate = templateName || 'A';
    if (userId) {
      const user = await User.findById(userId);
      if (user) {
        activeTemplate = user.levelTemplate || 'A';
      }
    }

    const query = activeTemplate === 'A'
      ? { level: levelNumber, $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { level: levelNumber, templateName: activeTemplate };

    const level = await Level.findOne(query);

    if (!level) {
      throw new ApiError(404, `Level ${levelNumber} not found`);
    }

    // If userId is provided, apply user-specific network reward distribution
    let processedLevel = level;
    if (userId) {
      const user = await User.findById(userId);
      if (user) {
        // Fetch conversion rates from database/cache
        const conversionRates = await fetchConversionRates();

        const userNetworkRewards = getUserNetworkRewardsForLevel(user, levelNumber);
        const levelObj = level.toObject();

        // Get stored distribution for this level to prevent re-randomization
        const storedDistField = `lvl${levelNumber}DistributedNodes`;
        const storedDist = user[storedDistField] ? Object.fromEntries(user[storedDistField]) : null;

        // Distribute rewards (will use stored if available, or create new)
        const { levelData, newDistribution } = distributeNetworkRewards(levelObj, userNetworkRewards, conversionRates, storedDist);
        processedLevel = levelData;

        // If new distribution was created (first time), save it to user
        if (newDistribution) {
          user[storedDistField] = new Map(Object.entries(newDistribution));
          await user.save();
          console.log(`[Level Controller] Stored new distribution for user ${userId}, level ${levelNumber}`);
        }

        console.log(`[Level Controller] Applied user-specific USD rewards for user ${userId}, level ${levelNumber}`);
      } else {
        console.log(`[Level Controller] User ${userId} not found, returning default level`);
      }
    }

    res.status(200).json({
      success: true,
      message: `Level ${levelNumber} retrieved successfully`,
      data: { level: processedLevel }
    });
  } catch (error) {
    next(error);
  }
};

// Create new level (Admin only)
export const createLevel = async (req, res, next) => {
  try {
    const { level, name, description, nodes, edges, templateName } = req.body;
    const activeTemplate = templateName || 'A';

    // Check if level already exists in this template
    const query = activeTemplate === 'A'
      ? { level, $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { level, templateName: activeTemplate };

    const existingLevel = await Level.findOne(query);
    if (existingLevel) {
      throw new ApiError(400, `Level ${level} already exists in template ${activeTemplate}`);
    }

    const newLevel = await Level.create({
      level,
      templateName: activeTemplate,
      name,
      description,
      nodes,
      edges
    });

    res.status(201).json({
      success: true,
      message: `Level ${level} created successfully`,
      data: { level: newLevel }
    });
  } catch (error) {
    next(error);
  }
};

// Update level (Admin only)
export const updateLevel = async (req, res, next) => {
  try {
    const { levelId } = req.params;
    const levelNumber = parseInt(levelId);
    const { templateName, ...updateData } = req.body;
    const activeTemplate = templateName || 'A';

    if (isNaN(levelNumber)) {
      throw new ApiError(400, 'Invalid level ID');
    }

    // Remove level from updateData to prevent changing the level number
    delete updateData.level;

    const query = activeTemplate === 'A'
      ? { level: levelNumber, $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { level: levelNumber, templateName: activeTemplate };

    const updatedLevel = await Level.findOneAndUpdate(
      query,
      {
        ...updateData,
        'metadata.updatedAt': new Date()
      },
      { new: true, runValidators: true }
    );

    if (!updatedLevel) {
      throw new ApiError(404, `Level ${levelNumber} not found`);
    }

    res.status(200).json({
      success: true,
      message: `Level ${levelNumber} updated successfully`,
      data: { level: updatedLevel }
    });
  } catch (error) {
    next(error);
  }
};

// Delete level (Admin only)
export const deleteLevel = async (req, res, next) => {
  try {
    const { levelId } = req.params;
    const { templateName } = req.query;
    const levelNumber = parseInt(levelId);
    const activeTemplate = templateName || 'A';

    if (isNaN(levelNumber)) {
      throw new ApiError(400, 'Invalid level ID');
    }

    const query = activeTemplate === 'A'
      ? { level: levelNumber, $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { level: levelNumber, templateName: activeTemplate };

    const deletedLevel = await Level.findOneAndDelete(query);

    if (!deletedLevel) {
      throw new ApiError(404, `Level ${levelNumber} not found`);
    }

    res.status(200).json({
      success: true,
      message: `Level ${levelNumber} deleted successfully`,
      data: { level: deletedLevel }
    });
  } catch (error) {
    next(error);
  }
};

// Get all unique template names
export const getTemplates = async (req, res, next) => {
  try {
    const templates = await Level.distinct('templateName');

    // Ensure 'A' is always included if there's any data
    if (templates.length > 0 && !templates.includes('A')) {
      templates.push('A');
    } else if (templates.length === 0) {
      templates.push('A');
    }

    res.status(200).json({
      success: true,
      data: templates.sort()
    });
  } catch (error) {
    next(error);
  }
};

export const cloneTemplate = async (req, res, next) => {
  try {
    const { fromTemplate, toTemplate } = req.body;

    if (!fromTemplate || !toTemplate) {
      throw new ApiError(400, 'Source and destination templates are required');
    }

    if (fromTemplate === toTemplate) {
      throw new ApiError(400, 'Source and destination templates must be different');
    }

    // Check if destination template already has any levels
    const existingLevelsCount = await Level.countDocuments({ templateName: toTemplate });
    if (existingLevelsCount > 0) {
      throw new ApiError(400, `Destination template "${toTemplate}" already has ${existingLevelsCount} levels. Delete them first to clone.`);
    }

    // Find all levels from source template
    const sourceQuery = fromTemplate === 'A'
      ? { $or: [{ templateName: 'A' }, { templateName: { $exists: false } }] }
      : { templateName: fromTemplate };

    const sourceLevels = await Level.find(sourceQuery);

    if (sourceLevels.length === 0) {
      throw new ApiError(404, `No levels found in source template "${fromTemplate}"`);
    }

    // Prepare cloned levels
    const clonedLevels = sourceLevels.map(lvl => {
      const levelObj = lvl.toObject();
      delete levelObj._id; // Remove ID to allow new document creation
      return {
        ...levelObj,
        templateName: toTemplate,
        metadata: {
          ...levelObj.metadata,
          createdAt: new Date(),
          updatedAt: new Date()
        }
      };
    });

    // Bulk insert cloned levels
    await Level.insertMany(clonedLevels);

    res.status(201).json({
      success: true,
      message: `Successfully cloned ${clonedLevels.length} levels from "${fromTemplate}" to "${toTemplate}"`,
      data: {
        count: clonedLevels.length,
        templateName: toTemplate
      }
    });
  } catch (error) {
    next(error);
  }
};
